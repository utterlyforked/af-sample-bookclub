# Foundation Infrastructure — Engineering Spec

**Type**: foundation  
**Component**: foundation-infrastructure  
**Dependencies**: None (this is the root dependency)  
**Status**: Ready for Implementation

---

## Overview

This specification defines the shared infrastructure that all features depend on: database schema, authentication, authorization, API patterns, frontend shell, and core services (geocoding, image processing, email, notifications, background jobs, spatial queries, messaging). It establishes the technical contracts for User, Tool, BorrowRequest, Rating, and other foundation entities, along with the services that manipulate them. Engineers implementing features will reference these entities and services without redefining them.

---

## Data Model

### User

**Table**: `users` (extends ASP.NET Core Identity `AspNetUsers`)

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | Generated by Identity framework |
| email | string(256) | unique, not null | Normalized to lowercase |
| password_hash | string(512) | not null | Hashed with bcrypt cost factor 12 |
| first_name | string(100) | not null | Part of DisplayName |
| last_name | string(100) | not null | Part of DisplayName |
| neighborhood | string(100) | not null | Geocoded or user-provided |
| latitude | decimal(10,7) | not null | WGS84 coordinate |
| longitude | decimal(10,7) | not null | WGS84 coordinate |
| location_accuracy | enum | not null | Values: 'precise', 'postal_code' |
| profile_photo_url | string(500) | nullable | Blob storage URL |
| profile_photo_thumbnail_url | string(500) | nullable | Blob storage URL |
| bio | string(300) | nullable | Plain text |
| phone_number | string(20) | nullable | E.164 format |
| phone_verified | boolean | not null, default false | |
| email_verified | boolean | not null, default false | |
| address_verified | boolean | not null, default false | |
| user_timezone | string(50) | not null, default 'UTC' | IANA timezone (e.g., "America/Los_Angeles") |
| member_since | timestamp | not null | Set to UTC now on registration |
| cached_tools_owned | int | not null, default 0 | Updated by background job |
| cached_tools_shared | int | not null, default 0 | Count of Status='Completed' borrows as owner |
| cached_current_borrows | int | not null, default 0 | Count of Status IN ('PickedUp') as borrower |
| cached_average_rating | decimal(3,2) | nullable | Null if no ratings, else avg(stars) |
| cached_rating_count | int | not null, default 0 | Count of received ratings |
| stats_last_updated | timestamp | nullable | Set by UpdateUserStatistics job |
| created_at | timestamp | not null | UTC timestamp |
| updated_at | timestamp | not null | UTC timestamp |

**Indexes**:
- `(email)` unique
- `(latitude, longitude)` GiST spatial index using `ll_to_earth(latitude, longitude)`
- `(phone_number)` for verification lookups

**Relationships**:
- Has many `Tool` (as owner)
- Has many `BorrowRequest` (as borrower and as owner)
- Has many `Rating` (as rater and as rated)
- Has many `UserFollow` (as follower and as followed)
- Has many `Notification`
- Has many `RequestMessage` (as sender and recipient)

**Business Rules**:
1. Email is normalized to lowercase before storage and lookup
2. Users may not change their email address after registration (enforce in application)
3. `location_accuracy = 'postal_code'` triggers UI warning: "Location is approximate. Add full address for better matches."
4. DisplayName is computed as `first_name + " " + last_name` (not stored)
5. User.latitude/longitude automatically replicated to all owned Tools on address change

---

### Tool

**Table**: `tools`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | Generated on insert |
| owner_id | UUID | FK to User, not null | |
| title | string(100) | not null | |
| category | enum | not null | Values: 'Power Tools', 'Hand Tools', 'Lawn & Garden', 'Ladders & Scaffolding', 'Plumbing', 'Electrical', 'Automotive', 'Other' |
| description | string(2000) | not null | Plain text |
| condition_notes | string(500) | nullable | Plain text |
| status | enum | not null, default 'Draft' | Values: 'Draft', 'Published', 'Borrowed', 'Unavailable' |
| location_lat | decimal(10,7) | not null | Mirrors owner's latitude |
| location_lng | decimal(10,7) | not null | Mirrors owner's longitude |
| primary_photo_id | UUID | FK to ToolPhoto, nullable | Set after first photo upload |
| created_at | timestamp | not null | UTC |
| updated_at | timestamp | not null | UTC |
| published_at | timestamp | nullable | Set when status transitions to 'Published' |

**Indexes**:
- `(owner_id, status)` for "My Tools" queries
- `(location_lat, location_lng)` GiST spatial index using `ll_to_earth(location_lat, location_lng)`
- `(category, status)` for category filtering
- `(status, published_at DESC)` for recent listings

**Relationships**:
- Belongs to `User` (owner)
- Has many `ToolPhoto` (cascade delete)
- Has many `BorrowRequest`
- Has many `ActivityEvent` (for community feed)

**Business Rules**:
1. Tool.location_lat/lng always match Tool.owner.latitude/longitude (synced automatically on owner address change)
2. Tool.status transitions: Draft → Published (user publishes) | Published → Borrowed (borrow approved) | Borrowed → Published (return confirmed) | any → Unavailable (user marks unavailable) | Unavailable → Published (user re-enables)
3. Tool may not be deleted if BorrowRequest exists with Status IN ('Pending', 'Approved', 'PickedUp')
4. When Tool.status transitions to 'Published' for the first time, create ActivityEvent with EventType='NewToolListed'

---

### ToolPhoto

**Table**: `tool_photos`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| tool_id | UUID | FK to Tool, not null | |
| image_url | string(500) | not null | Blob storage URL (full size) |
| thumbnail_url | string(500) | not null | Blob storage URL (400px) |
| display_order | int | not null | 1-based ordering |
| uploaded_at | timestamp | not null | UTC |

**Indexes**:
- `(tool_id, display_order)` unique

**Relationships**:
- Belongs to `Tool`

**Business Rules**:
1. Max 5 photos per tool (enforce in application before upload)
2. Accepted formats: HEIC, JPEG, PNG, WebP (max 10MB per file)
3. HEIC files converted to JPEG server-side
4. Full image resized to max 1920px width, thumbnail to 400px width
5. On delete, remove files from blob storage (cascade)

---

### BorrowRequest

**Table**: `borrow_requests`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| tool_id | UUID | FK to Tool, not null | |
| borrower_user_id | UUID | FK to User, not null | |
| owner_user_id | UUID | FK to User, not null | |
| requested_start_date | date | not null | Local date (no time) |
| requested_end_date | date | not null | Local date (no time) |
| original_due_date | date | nullable | Set to requested_end_date when approved |
| current_due_date | date | nullable | Updated by extension approvals |
| project_description | string(500) | not null | 50-500 chars |
| status | enum | not null, default 'Pending' | Values: 'Pending', 'Approved', 'Declined', 'Cancelled', 'Withdrawn', 'PickedUp', 'Returned', 'Completed' |
| owner_message | string(500) | nullable | Set on approval |
| decline_reason | string(500) | nullable | Required if status='Declined' (20-500 chars) |
| withdraw_reason | string(500) | nullable | Required if status='Withdrawn' (20-500 chars) |
| owner_timezone | string(50) | not null | Copied from owner.user_timezone on creation |
| tool_title_snapshot | string(100) | not null | Snapshot for history |
| tool_description_snapshot | string(2000) | not null | Snapshot for history |
| tool_primary_photo_url_snapshot | string(500) | nullable | Snapshot for history |
| tool_category_snapshot | enum | not null | Snapshot for history |
| created_at | timestamp | not null | UTC |
| responded_at | timestamp | nullable | Set when status changes to Approved/Declined |
| picked_up_at | timestamp | nullable | Set when status='PickedUp' |
| returned_at | timestamp | nullable | Set when status='Returned' |
| confirmed_at | timestamp | nullable | Set when status='Completed' |
| rating_window_closes_at | timestamp | nullable | confirmed_at + 7 days |

**Indexes**:
- `(borrower_user_id, status)` for borrower dashboard
- `(owner_user_id, status)` for owner dashboard
- `(tool_id, status)` for tool availability checks
- `(status, current_due_date)` for reminder jobs (WHERE status='PickedUp' AND current_due_date <= today+1)
- Exclusion constraint: `(tool_id, tsrange(requested_start_date, requested_end_date, '[]'))` EXCLUDE USING GIST WHERE status='Approved' (prevents double-booking)

**Relationships**:
- Belongs to `Tool`
- Belongs to `User` (borrower)
- Belongs to `User` (owner)
- Has many `RequestMessage`
- Has many `ExtensionRequest`
- Has one `ReturnConfirmation`
- Has many `BorrowNote`
- Has many `BorrowReminder`
- Has many `Rating` (max 2: one from borrower, one from owner)

**Business Rules**:
1. BorrowRequest transitions: Pending → Approved/Declined/Withdrawn | Approved → PickedUp/Cancelled | PickedUp → Returned | Returned → Completed (after confirmation or auto-confirm)
2. requested_end_date must be > requested_start_date
3. owner_user_id must equal tool.owner_id (enforce on creation)
4. owner_timezone copied from owner.user_timezone on creation (immutable for reminder consistency)
5. Snapshots (tool_title_snapshot, etc.) captured on creation for immutable transaction history
6. Auto-decline if approval attempt overlaps with existing approved request (checked by exclusion constraint)
7. Extension approval updates current_due_date only (original_due_date immutable)
8. When status='Completed', set confirmed_at and rating_window_closes_at = confirmed_at + 7 days

---

### RequestMessage

**Table**: `request_messages`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| borrow_request_id | UUID | FK to BorrowRequest, not null | |
| sender_user_id | UUID | FK to User, not null | |
| recipient_user_id | UUID | FK to User, not null | |
| message_text | string(1000) | not null | Plain text |
| read_at | timestamp | nullable | Set when recipient views message |
| created_at | timestamp | not null | UTC |

**Indexes**:
- `(borrow_request_id, created_at DESC)` for thread display
- `(recipient_user_id, read_at)` for unread count (WHERE read_at IS NULL)

**Relationships**:
- Belongs to `BorrowRequest`
- Belongs to `User` (sender)
- Belongs to `User` (recipient)

**Business Rules**:
1. sender_user_id must be borrower or owner of BorrowRequest
2. recipient_user_id must be the other party (borrower ↔ owner)
3. Messages read-only after BorrowRequest.status = 'Completed' (no new messages)
4. Message digest email sent 2 hours after first unread message (batched per user)

---

### ExtensionRequest

**Table**: `extension_requests`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| borrow_request_id | UUID | FK to BorrowRequest, not null | |
| requested_new_due_date | date | not null | Must be > current_due_date |
| reason | string(500) | not null | Borrower explanation |
| status | enum | not null, default 'Pending' | Values: 'Pending', 'Approved', 'Denied', 'TimedOut' |
| response_message | string(500) | nullable | Owner explanation (optional) |
| expires_at | timestamp | not null | created_at + 72 hours |
| created_at | timestamp | not null | UTC |
| responded_at | timestamp | nullable | Set on Approved/Denied |

**Indexes**:
- `(borrow_request_id, created_at DESC)`
- `(status, expires_at)` for timeout job (WHERE status='Pending' AND expires_at < now())

**Relationships**:
- Belongs to `BorrowRequest`

**Business Rules**:
1. requested_new_due_date must be > BorrowRequest.current_due_date
2. Only one Pending ExtensionRequest allowed per BorrowRequest at a time
3. Expires after 72 hours if no response (status='TimedOut')
4. On approval: BorrowRequest.current_due_date = requested_new_due_date, create Notification for borrower
5. On denial: create Notification for borrower with response_message
6. Background job checks hourly for expired extensions (expires_at < now() AND status='Pending')

---

### ReturnConfirmation

**Table**: `return_confirmations`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| borrow_request_id | UUID | FK to BorrowRequest, unique, not null | One per borrow |
| has_damage | boolean | not null, default false | Owner reported issue |
| damage_description | string(1000) | nullable | Required if has_damage=true |
| damage_photo_urls | text[] | nullable | Array of blob storage URLs |
| borrower_rebuttal | string(1000) | nullable | Borrower response to damage claim |
| auto_confirmed | boolean | not null, default false | True if 7-day auto-confirm triggered |
| marked_returned_at | timestamp | not null | When borrower clicked "Mark Returned" |
| confirmed_at | timestamp | nullable | When owner confirmed or auto-confirm ran |

**Indexes**:
- `(borrow_request_id)` unique
- `(marked_returned_at)` for auto-confirm job (WHERE confirmed_at IS NULL AND marked_returned_at < now() - 7 days)

**Relationships**:
- Belongs to `BorrowRequest`

**Business Rules**:
1. Created when borrower transitions BorrowRequest.status to 'Returned'
2. If has_damage=true, damage_description required (20-1000 chars)
3. Auto-confirmation after 7 days if owner hasn't responded: set confirmed_at, auto_confirmed=true, BorrowRequest.status='Completed'
4. Borrower may add rebuttal within 7 days of damage report
5. damage_photo_urls stored in blob container: `toolshare-images/damage-reports/{return_confirmation_id}/{photo_id}.jpg`

---

### BorrowNote

**Table**: `borrow_notes`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| borrow_request_id | UUID | FK to BorrowRequest, not null | |
| author_user_id | UUID | FK to User, not null | |
| note_text | string(1000) | not null | Private note |
| created_at | timestamp | not null | UTC |

**Indexes**:
- `(borrow_request_id, created_at DESC)`

**Relationships**:
- Belongs to `BorrowRequest`
- Belongs to `User` (author)

**Business Rules**:
1. author_user_id must be borrower or owner of BorrowRequest
2. Notes visible only to author (private)
3. Used for personal reminders, condition tracking

---

### BorrowReminder

**Table**: `borrow_reminders`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| borrow_request_id | UUID | FK to BorrowRequest, not null | |
| reminder_type | enum | not null | Values: 'DueSoon', 'DueToday', 'Overdue' |
| days_overdue | int | nullable | Set if reminder_type='Overdue' |
| sent_at | timestamp | not null | UTC |

**Indexes**:
- `(borrow_request_id, reminder_type, sent_at DESC)`

**Relationships**:
- Belongs to `BorrowRequest`

**Business Rules**:
1. Created when reminder email sent (prevents duplicate sends)
2. DueSoon: sent 1 day before current_due_date at 9 AM owner timezone
3. DueToday: sent on current_due_date at 9 AM owner timezone
4. Overdue: sent daily at 9 AM owner timezone if status='PickedUp' AND current_due_date < today

---

### Rating

**Table**: `ratings`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| transaction_id | UUID | FK to BorrowRequest, not null | WHERE status='Completed' |
| rater_user_id | UUID | FK to User, not null | |
| rated_user_id | UUID | FK to User, not null | |
| stars | int | not null, check (stars >= 1 AND stars <= 5) | |
| review_text | string(500) | nullable | Optional |
| visible | boolean | not null, default false | True when mutual or 7-day window expires |
| created_at | timestamp | not null | UTC |

**Indexes**:
- `(transaction_id, rater_user_id)` unique (prevents duplicate ratings)
- `(rated_user_id, visible)` for profile rating calculations (WHERE visible=true)

**Relationships**:
- Belongs to `BorrowRequest` (transaction)
- Belongs to `User` (rater)
- Belongs to `User` (rated)

**Business Rules**:
1. Rating may only be created if BorrowRequest.status='Completed'
2. rater_user_id must be borrower or owner of transaction
3. rated_user_id must be the other party
4. Exactly 2 ratings per transaction (one from each party)
5. visible=false until: (a) both parties rated (mutual), OR (b) 7 days elapsed since transaction.rating_window_closes_at
6. Background job checks daily for expired rating windows: set visible=true WHERE created_at < rating_window_closes_at AND visible=false

---

### UserFollow

**Table**: `user_follows`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| follower_user_id | UUID | FK to User, not null | |
| followed_user_id | UUID | FK to User, not null | |
| created_at | timestamp | not null | UTC |

**Indexes**:
- `(follower_user_id, followed_user_id)` unique
- `(followed_user_id)` for "Followers" list

**Relationships**:
- Belongs to `User` (follower)
- Belongs to `User` (followed)

**Business Rules**:
1. follower_user_id != followed_user_id (check constraint prevents self-follow)
2. Used for "My Network" tool prioritization in search results
3. Following is one-way (not mutual by default)

---

### ActivityEvent

**Table**: `activity_events`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| event_type | enum | not null | Values: 'NewToolListed', 'SuccessfulBorrow' |
| tool_id | UUID | FK to Tool, not null | |
| tool_name | string(100) | not null | Snapshot for deleted tools |
| tool_category | enum | not null | Snapshot |
| neighborhood | string(100) | not null | From owner's location |
| created_at | timestamp | not null | UTC, indexed for "Recent Activity" feed |

**Indexes**:
- `(created_at DESC)` for activity feed pagination
- `(neighborhood, created_at DESC)` for localized feed

**Relationships**:
- Belongs to `Tool` (nullable on cascade delete)

**Business Rules**:
1. NewToolListed: created when Tool.status transitions to 'Published' for first time (published_at IS NOT NULL AND previous published_at WAS NULL)
2. SuccessfulBorrow: created when BorrowRequest.status transitions to 'Completed'
3. Activity feed displays last 50 events, paginated (20 per page)
4. Snapshots (tool_name, category, neighborhood) preserved if tool deleted

---

### Notification

**Table**: `notifications`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| user_id | UUID | FK to User, not null | |
| notification_type | enum | not null | See Business Rules for values |
| title | string(200) | not null | Display in notification center |
| content | string(500) | not null | Detail text |
| action_url | string(500) | nullable | Link to relevant page |
| read | boolean | not null, default false | |
| created_at | timestamp | not null | UTC |
| read_at | timestamp | nullable | Set when user marks read |

**Indexes**:
- `(user_id, read, created_at DESC)` for unread badge count and inbox display

**Relationships**:
- Belongs to `User`

**Business Rules**:
1. notification_type values: 'Reminder_DueSoon', 'Reminder_DueToday', 'Reminder_Overdue', 'Return_Marked', 'Return_Confirmed', 'Extension_Requested', 'Extension_Approved', 'Extension_Denied', 'Extension_TimedOut', 'Damage_Reported', 'Rebuttal_Added', 'Rating_Reminder', 'Rating_Mutual', 'Request_Received', 'Request_Approved', 'Request_Declined'
2. All notifications sent via dual channel: (a) create Notification record, (b) send email via Email Service
3. Frontend polls `/api/v1/notifications/unread-count` every 60 seconds
4. Bell icon in header shows badge with unread count

---

### EmailDeliveryLog

**Table**: `email_delivery_log`

| Field | Type | Constraints | Notes |
|-------|------|-------------|-------|
| id | UUID | PK, not null | |
| recipient_email | string(256) | not null | |
| email_type | string(100) | not null | E.g., 'WelcomeEmail', 'DueReminder' |
| subject | string(500) | not null | |
| sent_at | timestamp | not null | UTC |
| delivery_status | enum | not null, default 'Pending' | Values: 'Pending', 'Sent', 'Bounced', 'Failed' |
| retry_count | int | not null, default 0 | Max 1 retry after 5 minutes |
| external_message_id | string(200) | nullable | SendGrid/Azure message ID |

**Indexes**:
- `(recipient_email, sent_at DESC)`
- `(delivery_status, sent_at)` for retry job

**Relationships**: None

**Business Rules**:
1. Created before sending email
2. If send fails, retry once after 5 minutes (update retry_count, sent_at)
3. If retry fails, set delivery_status='Failed' and alert monitoring
4. SendGrid webhook updates delivery_status to 'Bounced' if bounce detected

---

## API Endpoints

### POST /api/v1/auth/register

**Auth**: None (public)  
**Authorization**: None

**Request body**:
| Field | Type | Required | Validation |
|-------|------|----------|-----------|
| email | string | yes | Valid email format, max 256 chars, not already registered |
| password | string | yes | Min 8 chars, >= 1 uppercase, >= 1 lowercase, >= 1 digit |
| firstName | string | yes | Non-empty, max 100 chars |
| lastName | string | yes | Non-empty, max 100 chars |
| address | string | yes | Full address for geocoding (e.g., "123 Main St, Seattle, WA 98101") |
| phoneNumber | string | no | E.164 format (e.g., "+12065551234") |

**Success response** `201 Created`:
| Field | Type | Notes |
|-------|------|-------|
| userId | UUID | |
| email | string | |
| displayName | string | firstName + " " + lastName |
| emailVerified | boolean | Always false (verification email sent) |
| createdAt | ISO 8601 datetime | UTC |

**Error responses**:
| Status | Condition |
|--------|-----------|
| 400 | Validation failure — returns `{ "errors": { "email": ["Invalid email format"], "password": ["Password too weak"] } }` |
| 409 | Email already registered |
| 503 | Geocoding service unavailable |

**Side effects**:
1. Hash password with bcrypt (cost factor 12)
2. Geocode address to (latitude, longitude, location_accuracy) via Geocoding Service
3. If geocoding fails on address, retry with postal code extracted from address
4. If postal code geocoding succeeds, set location_accuracy='postal_code'
5. If both fail, return 400 with error: "Unable to verify address. Please check and try again."
6. Set user_timezone based on geocoded coordinates (use timezone lookup API or default to 'America/Los_Angeles' if West Coast, etc.)
7. Send email verification via Email Service (template: WelcomeEmail with verification token link)
8. Set JWT token in HttpOnly cookie (expires 7 days)

---

### POST /api/v1/auth/login

**Auth**: None (public)  
**Authorization**: None

**Request body**:
| Field | Type | Required | Validation |
|-------|------|----------|-----------|
| email | string | yes | Normalized to lowercase |
| password | string | yes | Plain text (validated against hash) |

**Success response** `200 OK`:
| Field | Type | Notes |
|-------|------|-------|
| userId | UUID | |
| email | string | |
| displayName | string | |
| emailVerified | boolean | |
| profilePhotoUrl | string | Nullable |

**Error responses**:
| Status | Condition |
|--------|-----------|
| 401 | Invalid email or password |
| 429 | Too many login attempts (rate limit: 10 per IP per hour) |

**Side effects**:
1. Set JWT token in HttpOnly cookie (expires 7 days)
2. Update User.updated_at

---

### POST /api/v1/auth/logout

**Auth**: Required (Bearer JWT)  
**Authorization**: Authenticated

**Request body**: None

**Success response** `204 No Content`

**Error responses**:
| Status | Condition |
|--------|-----------|
| 401 | Not authenticated |

**Side effects**:
1. Clear JWT cookie

---

### GET /api/v1/auth/me

**Auth**: Required (Bearer JWT)  
**Authorization**: Authenticated

**Success response** `200 OK`:
| Field | Type | Notes |
|-------|------|-------|
| userId | UUID | |
| email | string | |
| displayName | string | |
| firstName | string | |
| lastName | string | |
| neighborhood | string | |
| latitude | decimal | |
| longitude | decimal | |
| locationAccuracy | enum | 'precise' or 'postal_code' |
| profilePhotoUrl | string | Nullable |
| bio | string | Nullable |
| phoneNumber | string | Nullable |
| phoneVerified | boolean | |
| emailVerified | boolean | |
| addressVerified | boolean | |
| userTimezone | string | IANA timezone |
| memberSince | ISO 8601 datetime | |
| cachedToolsOwned | int | |
| cachedToolsShared | int | |
| cachedCurrentBorrows | int | |
| cachedAverageRating | decimal | Nullable (null if no ratings) |
| cachedRatingCount | int | |

**Error responses**:
| Status | Condition |
|--------|-----------|
| 401 | Not authenticated |

---

### POST /api/v1/auth/verify-email

**Auth**: None (public, token-based)  
**Authorization**: None

**Request body**:
| Field | Type | Required | Validation |
|-------|------|----------|-----------|
| token | string | yes | JWT token from verification email |

**Success response** `200 OK`:
| Field | Type | Notes |
|-------|------|-------|
| message | string | "Email verified successfully" |

**Error responses**:
| Status | Condition |
|--------|-----------|
| 400 | Invalid or expired token |

**Side effects**:
1. Set User.email_verified = true
2. Update User.updated_at

---

### POST /api/v1/auth/request-password-reset

**Auth**: None (public)  
**Authorization**: None

**Request body**:
| Field | Type | Required | Validation |
|-------|------|----------|-----------|
| email | string | yes | Valid email format |

**Success response** `200 OK`:
| Field | Type | Notes |
|-------|------|-------|
| message | string | "If an account exists, a reset link has been sent" (security: don't reveal if email exists) |

**Error responses**:
| Status | Condition |
|--------|-----------|
| 429 | Too many reset requests (rate limit: 3 per email per hour) |

**Side effects**:
1. If email exists, generate password reset token (JWT, expires 1 hour)
2. Send password reset email via Email Service (template: PasswordResetEmail with token link)

---

### POST /api/v1/auth/reset-password

**Auth**: None (public, token-based)  
**Authorization**: None

**Request body**:
| Field | Type | Required | Validation |
|-------|------|----------|-----------|
| token | string |